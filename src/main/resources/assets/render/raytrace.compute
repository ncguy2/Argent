#version 450 core

layout (binding = 0, rgba32f) uniform image2D fbo;
layout (local_size_x = 16, local_size_y = 8) in;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;

#define NUM_BOXES 2
#define MAX_SCENE_BOUNDS 1000.0

struct BoxDefinition {
    vec3 min;
    vec3 max;
};

struct hitInfo {
    vec2 lambda;
    int bi;
};

BoxDefinition boxes[NUM_BOXES] = {
    { vec3(-5.0, -0.1, -5.0), vec3(5.0, 0.0, 5.0) },
    { vec3(-0.5,  0.0, -0.5), vec3(0.5, 1.0, 0.5) }
};

vec2 intersectBox(vec3 origin, vec3 dir, const BoxDefinition b) {
    vec3 tMin = (b.min - origin) / dir;
    vec3 tMax = (b.max - origin) / dir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

bool intersectBoxes(vec3 origin, vec3 dir, out hitInfo hit) {
    float smallest = MAX_SCENE_BOUNDS;
    bool found = false;
    for(int i = 0; i < NUM_BOXES; i++) {
        vec2 lambda = intersectBox(origin, dir, boxes[i]);
        if(lambda.x > 0.0 && lambda.x < lambda.y && lambda.x < smallest) {
            hit.lambda = lambda;
            hit.bi = i;
            smallest = lambda.x;
            found = true;
        }
    }
    return found;
}

vec4 trace(vec3 origin, vec3 dir) {
    hitInfo i;
    if(intersectBoxes(origin, dir, i)) {
        vec3 gray = vec3(i.bi/10.0 + 0.8);
        return vec4(gray, 1.0);
    }
    return vec4(vec3(0.0), 1.0);
}

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(fbo);
    if(pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);
    vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
    vec4 colour = trace(eye, dir);
    imageStore(fbo, pix, colour);
}